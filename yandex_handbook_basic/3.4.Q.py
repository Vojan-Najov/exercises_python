# А есть ещё варианты?
# Ограничение времени
# 1 с
# Ограничение памяти
# 64.0 Мб
# Ввод
# стандартный ввод или input.txt
# Вывод
# стандартный вывод или output.txt
# Давайте вновь поможем Виталию выяснить, какие вариации вытащить из колоды
# определённые тройки карт возможны. Напишите программу, которая выводит список
# вариантов согласно требованиям.
# Формат ввода
# В первой строке записана масть, которая должна присутствовать в тройке. Во
# второй строке записан достоинство, которого не должно быть в тройке. В третьей
# строке записан предыдущий вариант полученный Виталием.
# Формат вывода
# Выведите следующий вариант расклада.
# Примечание
# Обратите внимание: валет-дама-король-туз лексикографически упорядочены.
# Но «10 ...» лексикографически младше, чем «2 ...», а бубны младше, чем пики.
# Масти в именительном и родительном падежах:
# Именительный  Родительный
# буби          бубен
# пики          пик
# трефы         треф
# черви         червей
# Пример 1
# Ввод
# пики
# 10
# 9 пик, король треф, туз червей
# Вывод
# 9 пик, король червей, туз бубен
# Пример 2
# Ввод
# трефы
# король
# 2 червей, туз пик, туз треф
# Вывод
# 2 червей, туз треф, туз червей

from itertools import product, combinations, dropwhile, islice

nominals = sorted(("2", "3", "4", "5", "6", "7", "8", "9", "10",
                  "валет", "дама", "король", "туз"))

masts = {"буби": "бубен",
         "пики": "пик",
         "трефы": "треф",
         "черви": "червей",
         }

in_mast, out_nominal = input(), input()
last_comb = tuple([tuple(comb.split()) for comb in input().split(", ")])

it = product(nominals, masts.values())
it = filter(lambda x: x[0] != out_nominal, it)
it = combinations(it, 3)
it = filter(lambda x: masts[in_mast] in (x[0][1], x[1][1], x[2][1]), it)
it = dropwhile(lambda x: x != last_comb, it)
it = islice(it, 1, 2)
for x in it:
    for i in range(len(x)):
        print(" ".join(x[i]), end=", " if i < len(x) - 1 else "\n")

